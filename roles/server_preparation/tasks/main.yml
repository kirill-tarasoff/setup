---
- name: Gather facts about network interfaces
  ansible.builtin.setup:
    gather_subset:
      - network
#
## Install necessary packages for encryption, disk operations, and system information retrieval
#- name: Install required packages
#  ansible.builtin.package:
#    name:
#      - cryptsetup
#      - util-linux
#      - lshw
#    state: present
#  register: package_install_result
#
#- name: Check package installation result
#  ansible.builtin.debug:
#    msg: "Packages installed successfully."
#  when: package_install_result is succeeded
#
## Ensure encryption variables are set before proceeding with encryption tasks
#- name: Check if encryption variables are set
#  ansible.builtin.debug:
#    msg: "Encryption variables are not set. Skipping encryption tasks."
#  when: "disk_to_encrypt == false and partition_to_encrypt == false"
#
## Conditional tasks for disk encryption
#- name: Ensure disk encryption is set
#  when: disk_to_encrypt != false
#  block:
#    - name: Ensure disk encryption with LUKS
#      community.crypto.luks_device:
#        name: "encrypted_disk"
#        device: "{{ disk_to_encrypt }}"
#        state: opened
#        passphrase: "{{ encrypt_pass }}"
#
#    - name: Create filesystem on encrypted disk
#      ansible.builtin.filesystem:
#        fstype: ext4
#        dev: "/dev/mapper/encrypted_disk"
#  rescue:
#    - name: Print when errors
#      ansible.builtin.debug:
#        msg: "Failed disk encryption"
#
## Conditional tasks for partition encryption
#- name: Ensure partition encryption is set
#  when: partition_to_encrypt != false
#  block:
#    - name: Ensure partition encryption with LUKS
#      community.crypto.luks_device:
#        name: "encrypted_partition"
#        device: "{{ partition_to_encrypt }}"
#        state: opened
#        passphrase: "{{ encrypt_pass }}"
#
#    - name: Create filesystem on encrypted partition
#      ansible.builtin.filesystem:
#        fstype: ext4
#        dev: "/dev/mapper/encrypted_partition"
#  rescue:
#    - name: Print when errors
#      ansible.builtin.debug:
#        msg: "Failed partition encryption"
#
## Check CPU power-saving state
#- name: Ensure CPU C-states
#  ansible.builtin.slurp:
#    path: /etc/default/grub
#  register: grub_content
#
## Disable CPU power-saving C-states by modifying GRUB configuration.
#- name: Disable CPU C-states
#  ansible.builtin.lineinfile:
#    path: /etc/default/grub
#    regexp: '^GRUB_CMDLINE_LINUX="(.*)"'
#    line: 'GRUB_CMDLINE_LINUX="\1 intel_idle.max_cstate=0"'
#    backrefs: yes
#  when: "'intel_idle.max_cstate=0' not in (grub_content.content | b64decode)"
#
## Apply changes to GRUB to disable C-states.
#- name: Apply GRUB changes
#  ansible.builtin.shell: update-grub
#
## Check scaling_governor status
#- name: Check if scaling_governor is available
#  ansible.builtin.stat:
#    path: /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
#  register: governor_status
#
## Switch CPUs from power-saving mode to performance mode if applicable.
#- name: Set CPU to performance mode
#  ansible.builtin.shell:
#    cmd: "echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor"
#  when: governor_status.stat.exists

# Interface rename
# It could be implemented with network-manager (nmcli ansible module),
# but it's additional needed network-manager package
- name: Interface renaming
  block:

    # Get default interface
    - name: Debug default interface
      ansible.builtin.debug:
        msg: "Default interface: {{ ansible_facts['default_ipv4']['alias'] }}"

    - name: Check if the new interface name already exists
      ansible.builtin.command: "ip link show {{ new_interface_name }}"
      register: new_interface_check
      failed_when: false
      changed_when: false

    - name: Create new udev rule for renaming the interface
      ansible.builtin.blockinfile:
        path: /etc/udev/rules.d/99-persistent-net.rules
        create: true
        block: |
          # udev rule to rename network interface
          SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="{{ ansible_facts['default_ipv4']['macaddress'] }}", NAME="{{ new_interface_name }}"
      notify: Restart networking
      when: new_interface_check.rc != 0

    - name: Trigger udev to apply new rules
      ansible.builtin.shell:
        cmd: udevadm control --reload && udevadm trigger
      when: new_interface_check.rc != 0

    - name: Verify the renamed interface
      ansible.builtin.command:
        cmd: "ip link show {{ new_interface_name }}"
      register: verify_interface

    - name: Debug output of the renamed interface
      ansible.builtin.debug:
        var: verify_interface.stdout

  rescue:
    - name: Print when errors
      ansible.builtin.debug:
        msg: "Failed interface renaming"

# Display CPU model and Hyper-Threading support information.
- name: Show CPU and Hyper-Threading information
  ansible.builtin.shell:
    cmd: "lscpu | grep -E 'Model name|Thread(s) per core'"
  check_mode: true
  register: cpu_info

# Output CPU and Hyper-Threading support information.
- name: Output CPU information
  ansible.builtin.debug:
    var: cpu_info.stdout
